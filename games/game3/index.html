<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Perfect Rotating Fan</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  
<canvas id="gameCanvas"></canvas>
<script src="input.js"></script>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

const centerX = width / 2;
const centerY = height / 2;

const steps = 36;
const angleStep = (2 * Math.PI) / steps;
let currentStep = 0;

const bladeLength = Math.max(width, height) * 0.95;
const radarAngleSpan = Math.PI / 8;
const bladeHalfWidth = Math.tan(radarAngleSpan / 2) * bladeLength;

const rotateSound = new Audio(inputData.sounds.rotate);
const winSound = new Audio(inputData.sounds.win);

const numObjects = inputData.settings.numObjects;
const objectSize = inputData.settings.objectSize;
let objects = [];
let correctObjectIndex = Math.floor(Math.random() * numObjects);
let showObjects = true;
let hasDetected = false; // Detection flag

const defaultObjectImage = new Image();
defaultObjectImage.src = inputData.objectImage;

const correctObjectImage = new Image();
correctObjectImage.src = inputData.correctObjectImage;

const backgroundImage = new Image();
backgroundImage.src = inputData.background;

backgroundImage.onload = () => {
  createObjects();
  setTimeout(() => {
    showObjects = false;
    draw();
  }, inputData.settings.showDuration);
  draw();
};

function createObjects() {
  hasDetected = false; //Reset detection flag
  objects = [];
  correctObjectIndex = Math.floor(Math.random() * numObjects);
  for (let i = 0; i < numObjects; i++) {
    const x = Math.random() * (width - objectSize);
    const y = Math.random() * (height - objectSize);
    objects.push({ x, y, isCorrect: i === correctObjectIndex });
  }
}

function drawObjects() {
  if (!showObjects) return;

  objects.forEach(obj => {
    ctx.save();

    if (obj.isCorrect) {
      if (correctObjectImage.complete) {
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 20;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;
        ctx.drawImage(correctObjectImage, obj.x, obj.y, objectSize, objectSize);
      }
    } else {
      if (defaultObjectImage.complete) {
        ctx.shadowColor = 'transparent';
        ctx.drawImage(defaultObjectImage, obj.x, obj.y, objectSize, objectSize);
      }
    }

    ctx.restore();
  });
}

function drawTriangle(angle) {
  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.rotate(angle);

  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-bladeHalfWidth, bladeLength);
  ctx.lineTo(bladeHalfWidth, bladeLength);
  ctx.closePath();

  ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
  ctx.fill();
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.restore();
}

function checkDetection() {
  if (hasDetected) return; // Stop re-triggering

  const angle = currentStep * angleStep + Math.PI / 2;
  const endX = centerX + Math.cos(angle) * bladeLength;
  const endY = centerY + Math.sin(angle) * bladeLength;

  objects.forEach(obj => {
    if (obj.isCorrect) {
      const cx = obj.x + objectSize / 2;
      const cy = obj.y + objectSize / 2;
      const dist = distanceFromPointToLine(cx, cy, centerX, centerY, endX, endY);
      if (dist < objectSize / 2) {
        const detectionSound = new Audio(inputData.sounds.detection);
        detectionSound.currentTime = 0;
        detectionSound.play();

        winSound.currentTime = 0;
        winSound.play();
        // finishSCORM()

        hasDetected = true; 
        finishSCORM(); 
      }
    }
  });
}

function distanceFromPointToLine(px, py, x1, y1, x2, y2) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  const dot = A * C + B * D;
  const len_sq = C * C + D * D;
  const param = len_sq !== 0 ? dot / len_sq : -1;
  let xx, yy;
  if (param < 0) { xx = x1; yy = y1; }
  else if (param > 1) { xx = x2; yy = y2; }
  else { xx = x1 + param * C; yy = y1 + param * D; }
  return Math.hypot(px - xx, py - yy);
}

function draw() {
  ctx.clearRect(0, 0, width, height);
  ctx.drawImage(backgroundImage, 0, 0, width, height);
  drawTriangle(currentStep * angleStep);
  drawObjects();
  checkDetection();
}

function rotateBlade(direction) {
  currentStep = (direction === "right")
    ? (currentStep + 1) % steps
    : (currentStep - 1 + steps) % steps;
  rotateSound.currentTime = 0;
  rotateSound.play();
  draw();
}

// Mouse click rotation
canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  const dx = mouseX - centerX;
  const dy = mouseY - centerY;
  let angle = Math.atan2(dy, dx);
  if (angle < 0) angle += 2 * Math.PI;

  let step = Math.round((angle - Math.PI / 2) / angleStep);
  currentStep = (step + steps) % steps;

  rotateSound.currentTime = 0;
  rotateSound.play();
  draw();
});

document.addEventListener("keydown", (e) => {
  if (e.key === "ArrowRight") rotateBlade("right");
  else if (e.key === "ArrowLeft") rotateBlade("left");
});

window.addEventListener("resize", () => {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
  draw();
});

setInterval(draw, 40);

//pre-defined functions
let API
function findAPI(win) {
  let attempts = 0;
  const maxAttempts = 50;
  while (win && attempts < maxAttempts) {
      if (win.API) {
          console.log("Found SCORM API (1.2) in window");
          return win.API;
      }
      if (win.API_1484_11) {
          console.log("Found SCORM API (2004) in window");
          return win.API_1484_11;
      }
      try {
          console.log("Checking parent window at attempt", attempts);
          win = win.parent;
      } catch (e) {
          console.error("Error accessing parent window:", e);
          win = null;
      }
      attempts++;
  }
  if (window.opener && window.opener.API) {
      console.log("Found SCORM API (1.2) in opener");
      return window.opener.API;
  }
  if (window.opener && window.opener.API_1484_11) {
      console.log("Found SCORM API (2004) in opener");
      return window.opener.API_1484_11;
  }
  if (window.top && window.top.API) {
      console.log("Found SCORM API (1.2) in top");
      return window.top.API;
  }
  if (window.top && window.top.API_1484_11) {
      console.log("Found SCORM API (2004) in top");
      return window.top.API_1484_11;
  }
  for (let i = 0; i < window.frames.length; i++) {
      try {
          if (window.frames[i].API) {
              console.log("Found SCORM API (1.2) in frame", i);
              return window.frames[i].API;
          }
          if (window.frames[i].API_1484_11) {
              console.log("Found SCORM API (2004) in frame", i);
              return window.frames[i].API_1484_11;
          }
      } catch (e) {
          console.error("Error accessing frame", i, ":", e);
      }
  }
  console.error("SCORM API not found after checking all contexts");
  return null;
}

function initializeSCORM() {
  API = findAPI(window)
  if (!API) {
      console.error("SCORM API not found");
      return false;
  }
  const result = API.LMSInitialize("");
  if (result !== "true") {
      const errorCode = API.LMSGetLastError();
      const errorString = API.LMSGetErrorString(errorCode);
      console.error(`SCORM Initialization failed: Error ${errorCode} - ${errorString}`);
      return false;
  }
  console.log("SCORM Initialized");
  setSCORMValue("cmi.core.lesson_status", "incomplete");
  return true;
}
function setSCORMValue(key, value) {
  if (API) {
      const result = API.LMSSetValue(key, value);
      if (result !== "true") {
          const errorCode = API.LMSGetLastError();
          const errorString = API.LMSGetErrorString(errorCode);
          console.error(`Failed to set ${key}: Error ${errorCode} - ${errorString}`);
          return false;
      }
      API.LMSCommit("");
      return true;
  }
  console.error("Cannot set SCORM value: API not available");
  return false;
}
let startTime = Date.now();
function calculateSessionTime() {
  const seconds = Math.floor((Date.now() - startTime) / 1000);
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
}
async function finishSCORM() {
  if (API) {
      const sessionTime = calculateSessionTime();
      setSCORMValue('cmi.core.lesson_status', 'passed')
      const result = await API.LMSFinish("");
      if (result !== "true") {
          const errorCode = API.LMSGetLastError();
          const errorString = API.LMSGetErrorString(errorCode);
          console.error(`SCORM Finish failed: Error ${errorCode} - ${errorString}`);
          return `SCORM Finish failed: Error ${errorCode} - ${errorString}`;
      } else {
          console.log("SCORM Finished");
      }
  } else {
      return "SCORM API not available. Time spent: " + calculateSessionTime();
  }
}
initializeSCORM()

</script>
</body>
</html>