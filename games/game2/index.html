<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Drawing on PDF</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        font-family: sans-serif;
        height: 100vh;
        overflow: hidden;
      }

      #toolbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 10;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 20px;
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.95);
        border-bottom: 2px solid #ccc;
        flex-wrap: wrap;
      }

      #pdf-container {
        position: absolute;
        top: 60px;
        bottom: 60px;
        left: 0;
        right: 0;
        overflow: auto;
        background: #f1f1f1;
      }

      #pdf-wrapper {
        position: relative;
        width: 100%;
        height: fit-content;
      }

      #pdf-canvas,
      #draw-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: auto;
      }

      #pdf-controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 73rem;
        z-index: 20;
        background: rgba(255, 255, 255, 0.15);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: none;
      }

      #pdf-controls button {
        background: none;
        border: none;
        padding: 0;
        cursor: pointer;
      }

      #pdf-controls button img {
        width: 30px;
        height: 30px;
        object-fit: contain;
        border-radius: 50%;
        transition: transform 0.2s ease;
      }

      #pdf-controls button:hover img {
        transform: scale(1.1);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      #pdf-controls button:disabled img {
        filter: grayscale(100%);
        opacity: 0.5;
        cursor: not-allowed;
      }

      #prev-btn img {
        background-color: #f4b400;
      }

      #next-btn img {
        background-color: #0f9d58;
      }

      .color-palette {
        display: flex;
        gap: 10px;
      }

      .color-btn {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        border: 2px solid #fff;
        box-shadow: 0 0 3px rgba(0, 0, 0, 0.4);
        cursor: pointer;
      }

      .color-btn.selected {
        border: 3px solid black;
      }

      .actions {
        display: flex;
        gap: 60px;
        align-items: center;
      }

      .actions button {
        background: none;
        border: none;
        padding: 0;
        cursor: pointer;
      }

      .actions button img {
        width: 30px;
        height: 30px;
        object-fit: contain;
        border-radius: 50%;
        transition: transform 0.2s ease;
      }

      .actions button:hover img {
        transform: scale(1.1);
      }

      .brush-sizes {
        display: flex;
        gap: 6px;
      }

      .brush-sizes button.selected {
        background: black;
        color: white;
        border-radius: 4px;
      }
      #close-btn {
        background: #ff4d4d;
        color: white;
        border: none;
        padding: 5px 10px;
        font-size: 18px;
        border-radius: 10px;
        cursor: pointer;
        transition: background 0.3s;
      }
      #close-btn:hover {
        background: #ff1a1a;
      }
      
      
    </style>

    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Input JSON -->
    <script src="input.js"></script>
    <script>
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    </script>
  </head>
  <body>
    <div id="toolbar">
      <div class="color-palette">
        <div class="color-btn selected" style="background: black" data-color="black"></div>
        <div class="color-btn" style="background: red" data-color="red"></div>
        <div class="color-btn" style="background: green" data-color="green"></div>
        <div class="color-btn" style="background: blue" data-color="blue"></div>
        <div class="color-btn" style="background: orange" data-color="orange"></div>
        <div class="color-btn" style="background: purple" data-color="purple"></div>
        <div class="color-btn" style="background: pink" data-color="pink"></div>
      </div>
    
      <div class="actions">
        <button id="undo-btn" onclick="undoDraw()">
          <img src="./undo-removebg-preview.png" alt="Undo" />
        </button>
        <button id="redo-btn" onclick="redoDraw()">
          <img src="./redo-removebg-preview.png" alt="Redo" />
        </button>
        <button id="zoom-in-btn">
          <img src="./zoom-in__2_-removebg-preview.png" alt="Zoom In" />
        </button>
        <button id="zoom-out-btn">
          <img src="./zoom-in__1_-removebg-preview.png" alt="Zoom Out" />
        </button>
        <button id="close-btn" title="Exit">
          &#10005;
        </button>
      </div>
    
      <div class="brush-sizes">
        <button data-size="2">2px</button>
        <button data-size="4">4px</button>
        <button data-size="6">6px</button>
        <button data-size="8" class="selected">8px</button>
        <button data-size="10">10px</button>
      </div>
    </div>
    

    <div id="pdf-container">
      <div id="pdf-wrapper">
        <canvas id="pdf-canvas"></canvas>
        <canvas id="draw-canvas"></canvas>
      </div>
    </div>

    <div id="pdf-controls">
      <button id="prev-btn">
        <img src="./left-removebg-preview.png" alt="Previous" />
      </button>
      <button id="next-btn">
        <img src="./right-removebg-preview.png" alt="Next" />
      </button>
    </div>

    <script>
      const pdfCanvas = document.getElementById("pdf-canvas");
      const drawCanvas = document.getElementById("draw-canvas");
      const pdfCtx = pdfCanvas.getContext("2d");
      const drawCtx = drawCanvas.getContext("2d");
    
      const prevBtn = document.getElementById("prev-btn");
      const nextBtn = document.getElementById("next-btn");
      const zoomInBtn = document.getElementById("zoom-in-btn");
      const zoomOutBtn = document.getElementById("zoom-out-btn");
      const pdfWrapper = document.getElementById("pdf-wrapper");
    
      const pdfList = InputData.pdfFiles;
      let currentFileIndex = 0;
      let currentPage = 1;
      let pdfDoc = null;
      let scale = 1;
    
      const strokeHistory = [];
      const redoHistory = [];
      let isMousedown = false;
      let points = [];
      let brushSize = 8;
      let currentColor = "black";
    
      function updateNavButtons() {
        prevBtn.disabled = currentPage === 1 && currentFileIndex === 0;
        nextBtn.disabled = currentPage === pdfDoc.numPages && currentFileIndex === pdfList.length - 1;
      }
    
      function loadPDF(index) {
        if (index < 0 || index >= pdfList.length) return;
    
        strokeHistory.length = 0;
        redoHistory.length = 0;
        points = [];
        drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        pdfCtx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
    
        currentFileIndex = index;
        currentPage = 1;
    
        const pdfPath = `pdfs/${pdfList[currentFileIndex]}`;
        pdfjsLib.getDocument(pdfPath).promise.then((pdf) => {
          pdfDoc = pdf;
          renderPage(currentPage);
          updateNavButtons();
        }).catch(console.error);
      }
    
      function renderPage(pageNum) {
        pdfDoc.getPage(pageNum).then((page) => {
          const containerWidth = document.getElementById("pdf-container").clientWidth;
          const unscaledViewport = page.getViewport({ scale: 1 });
          const baseScale = containerWidth / unscaledViewport.width;
          const viewport = page.getViewport({ scale: baseScale });
    
          pdfCanvas.width = viewport.width;
          drawCanvas.width = viewport.width;
          pdfCanvas.height = viewport.height;
          drawCanvas.height = viewport.height;
    
          pdfWrapper.style.height = `${viewport.height}px`;
    
          const renderContext = { canvasContext: pdfCtx, viewport };
          page.render(renderContext).promise.then(() => {
            redrawCanvas();
            updateNavButtons();
          });
        }).catch(console.error);
      }
    
      function getCanvasCoordinates(e) {
        const rect = drawCanvas.getBoundingClientRect();
        let x, y;
        if (e.touches && e.touches[0]) {
          x = (e.touches[0].clientX - rect.left) * (drawCanvas.width / rect.width);
          y = (e.touches[0].clientY - rect.top) * (drawCanvas.height / rect.height);
        } else {
          x = (e.clientX - rect.left) * (drawCanvas.width / rect.width);
          y = (e.clientY - rect.top) * (drawCanvas.height / rect.height);
        }
        return { x, y };
      }
    
      function drawOnCanvas(stroke) {
        drawCtx.lineCap = "round";
        drawCtx.lineJoin = "round";
        const l = stroke.length - 1;
        if (stroke.length >= 3) {
          const xc = (stroke[l].x + stroke[l - 1].x) / 2;
          const yc = (stroke[l].y + stroke[l - 1].y) / 2;
          drawCtx.lineWidth = stroke[l - 1].lineWidth;
          drawCtx.strokeStyle = stroke[l - 1].color;
          drawCtx.quadraticCurveTo(stroke[l - 1].x, stroke[l - 1].y, xc, yc);
          drawCtx.stroke();
          drawCtx.beginPath();
          drawCtx.moveTo(xc, yc);
        } else {
          const point = stroke[l];
          drawCtx.lineWidth = point.lineWidth;
          drawCtx.strokeStyle = point.color;
          drawCtx.beginPath();
          drawCtx.moveTo(point.x, point.y);
          drawCtx.stroke();
        }
      }
    
      function redrawCanvas() {
        drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        strokeHistory.forEach((stroke) => {
          drawCtx.beginPath();
          stroke.forEach((point, idx) => {
            const strokePath = stroke.slice(0, idx + 1);
            drawOnCanvas(strokePath);
          });
        });
      }
    
      function undoDraw() {
        if (strokeHistory.length > 0) {
          redoHistory.push(strokeHistory.pop());
          redrawCanvas();
        }
      }
    
      function redoDraw() {
        if (redoHistory.length > 0) {
          strokeHistory.push(redoHistory.pop());
          redrawCanvas();
        }
      }
    
      function handleStart(e) {
        const { x, y } = getCanvasCoordinates(e);
        isMousedown = true;
        points.push({ x, y, lineWidth: brushSize, color: currentColor });
        drawOnCanvas(points);
      }
    
      function handleMove(e) {
        if (!isMousedown || points.length === 0) return;
        e.preventDefault();
        const { x, y } = getCanvasCoordinates(e);
        const last = points[points.length - 1];
        const dx = x - last.x;
        const dy = y - last.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance > brushSize * 1.5) {
          points.push({ x, y, lineWidth: brushSize, color: currentColor });
          drawOnCanvas(points);
        }
      }
    
      function handleEnd() {
        isMousedown = false;
        if (points.length > 0) {
          strokeHistory.push([...points]);
          points = [];
        }
      }
    
      document.querySelectorAll(".color-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          document.querySelectorAll(".color-btn").forEach((b) => b.classList.remove("selected"));
          btn.classList.add("selected");
          currentColor = btn.getAttribute("data-color");
        });
      });
    
      document.querySelectorAll(".brush-sizes button").forEach((btn) => {
        btn.addEventListener("click", () => {
          document.querySelectorAll(".brush-sizes button").forEach((b) => b.classList.remove("selected"));
          btn.classList.add("selected");
          brushSize = parseInt(btn.getAttribute("data-size"));
        });
      });
    
      // Navigation buttons
      prevBtn.addEventListener("click", () => {
        if (currentPage > 1) {
          currentPage--;
          renderPage(currentPage);
        } else if (currentFileIndex > 0) {
          currentFileIndex--;
          const pdfPath = `pdfs/${pdfList[currentFileIndex]}`;
          pdfjsLib.getDocument(pdfPath).promise.then((pdf) => {
            pdfDoc = pdf;
            currentPage = pdfDoc.numPages;
            renderPage(currentPage);
            updateNavButtons();
          }).catch(console.error);
        }
      });
    
      nextBtn.addEventListener("click", () => {
        if (currentPage < pdfDoc.numPages) {
          currentPage++;
          renderPage(currentPage);
        } else if (currentFileIndex < pdfList.length - 1) {
          loadPDF(currentFileIndex + 1);
        }
      });
    
      // Zoom handlers 
      zoomInBtn.addEventListener("click", () => {
        scale = Math.min(3, scale + 0.1);
        pdfWrapper.style.transform = `scale(${scale})`;
        pdfWrapper.style.transformOrigin = "top left";
      });
    
      zoomOutBtn.addEventListener("click", () => {
        scale = Math.max(1, scale - 0.1);
        pdfWrapper.style.transform = `scale(${scale})`;
        pdfWrapper.style.transformOrigin = "top left";
      });
    
      drawCanvas.addEventListener("mousedown", handleStart);
      drawCanvas.addEventListener("touchstart", handleStart);
      drawCanvas.addEventListener("mousemove", handleMove);
      drawCanvas.addEventListener("touchmove", handleMove);
      drawCanvas.addEventListener("mouseup", handleEnd);
      drawCanvas.addEventListener("touchend", handleEnd);
      drawCanvas.addEventListener("touchleave", handleEnd);

      function findAPI(win) {
        let attempts = 0;
        const maxAttempts = 50;
        while (win && attempts < maxAttempts) {
            if (win.API) {
                console.log("Found SCORM API (1.2) in window");
                return win.API;
            }
            if (win.API_1484_11) {
                console.log("Found SCORM API (2004) in window");
                return win.API_1484_11;
            }
            try {
                console.log("Checking parent window at attempt", attempts);
                win = win.parent;
            } catch (e) {
                console.error("Error accessing parent window:", e);
                win = null;
            }
            attempts++;
        }
        if (window.opener && window.opener.API) {
            console.log("Found SCORM API (1.2) in opener");
            return window.opener.API;
        }
        if (window.opener && window.opener.API_1484_11) {
            console.log("Found SCORM API (2004) in opener");
            return window.opener.API_1484_11;
        }
        if (window.top && window.top.API) {
            console.log("Found SCORM API (1.2) in top");
            return window.top.API;
        }
        if (window.top && window.top.API_1484_11) {
            console.log("Found SCORM API (2004) in top");
            return window.top.API_1484_11;
        }
        for (let i = 0; i < window.frames.length; i++) {
            try {
                if (window.frames[i].API) {
                    console.log("Found SCORM API (1.2) in frame", i);
                    return window.frames[i].API;
                }
                if (window.frames[i].API_1484_11) {
                    console.log("Found SCORM API (2004) in frame", i);
                    return window.frames[i].API_1484_11;
                }
            } catch (e) {
                console.error("Error accessing frame", i, ":", e);
            }
        }
        console.error("SCORM API not found after checking all contexts");
        return null;
    }
    function initializeSCORM() {
        API = findAPI(window)
        if (!API) {
            console.error("SCORM API not found");
            return false;
        }
        const result = API.LMSInitialize("");
        if (result !== "true") {
            const errorCode = API.LMSGetLastError();
            const errorString = API.LMSGetErrorString(errorCode);
            console.error(`SCORM Initialization failed: Error ${errorCode} - ${errorString}`);
            return false;
        }
        console.log("SCORM Initialized");
        setSCORMValue("cmi.core.lesson_status", "incomplete");
        return true;
    }
    function setSCORMValue(key, value) {
        if (API) {
            const result = API.LMSSetValue(key, value);
            if (result !== "true") {
                const errorCode = API.LMSGetLastError();
                const errorString = API.LMSGetErrorString(errorCode);
                console.error(`Failed to set ${key}: Error ${errorCode} - ${errorString}`);
                return false;
            }
            API.LMSCommit("");
            return true;
        }
        console.error("Cannot set SCORM value: API not available");
        return false;
    }
    let startTime = Date.now();
    function calculateSessionTime() {
        const seconds = Math.floor((Date.now() - startTime) / 1000);
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
    }
   async function finishSCORM() {
        if (API) {
            const sessionTime = calculateSessionTime();
            setSCORMValue('cmi.core.lesson_status', 'passed')
            const result =await API.LMSFinish("");
            if (result !== "true") {
                const errorCode = API.LMSGetLastError();
                const errorString = API.LMSGetErrorString(errorCode);
                console.error(`SCORM Finish failed: Error ${errorCode} - ${errorString}`);
                return `SCORM Finish failed: Error ${errorCode} - ${errorString}`;
            } else {
                console.log("SCORM Finished");
            }
        } else {
            return "SCORM API not available. Time spent: " + calculateSessionTime();
        }
    }
    initializeSCORM()

      document.getElementById("close-btn").addEventListener("click", async () => {
        const result = await finishSCORM();
        alert("Session closed.\n" + (result || "SCORM finished."));
        window.close(); 
      });
      
    
      loadPDF(0);
    </script>
    
  </body>
</html>
